package appinfo

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"io/ioutil"
	"math"
	"path/filepath"
	"slices"

	"strings"

	"golang.org/x/tools/go/ast/astutil"
)

type appInfo interface {
	PackageInfo
	HasUsedC(pb *build.Package) bool
	IsUsed(ast.Node) bool
	IsMethod(ast.Node) bool
	IsInit(ast.Node) bool
	GetEntryPointDecl() *ast.FuncDecl
	GetMethods(*ast.Ident) []*ast.Ident
	GetFuncDecl(*ast.Ident) *ast.FuncDecl
	GetFile(nd ast.Node) *ast.File
	GetPackage(nd ast.Node) *build.Package
	GetReferrings(nd ast.Node) []*ast.Ident
}

// SquashedApp represents an application combined into a single file
type SquashedApp struct {
	// pkgName is the name of package that has the entry point of the application
	pkgName string

	// xDecls are slices of *ast.GenDecl/*ast.FuncDecl of the combined application.
	// You can use it for printing out the application as a single file.
	// Note that each node in it is derived from various postions of files including token.NoPos.
	importDecls []ast.Decl
	decls       []ast.Decl

	// comments for decls
	comments map[ast.Decl][]*ast.CommentGroup

	// Fset keeps FileSet for the Syntax
	fset *token.FileSet
}

// newSquashedApp build SquashedApp from appInfo
func newSquashedApp(ai appInfo) (*SquashedApp, error) {
	// collect used items for the SquashedApp
	ingr := &ingredients{
		comments: make(map[ast.Decl][]*ast.CommentGroup),
	}
	fset := ai.FileSet()

	for _, bp := range ai.Packages() {
		if ai.HasUsedC(bp) {
			for _, f := range bp.CFiles {
				fname := filepath.Join(bp.ImportPath, f)
				fpath := filepath.Join(bp.Dir, f)
				decl, err := createImportDeclFromCFile(fset, fname, fpath)
				if err != nil {
					return nil, fmt.Errorf("creating func decls for C files: %w", err)
				}
				ingr.importCDecls = append(ingr.importCDecls, decl)
			}

		}
	}

	forEachFile(ai, func(bp *build.Package, f *ast.File) {
		var cidx int
		for _, decl := range f.Decls {
			var adding ast.Decl
			switch decl := decl.(type) {
			case *ast.GenDecl:
				switch decl.Tok {
				case token.IMPORT:
					specs, cdecls, cspecs := collectUsedImport(ai, decl)
					ingr.importSpecs = append(ingr.importSpecs, specs...)
					ingr.importCDecls = append(ingr.importCDecls, cdecls...)
					ingr.importCSpecs = append(ingr.importCSpecs, cspecs...)
				case token.CONST:
					if hasUsedValueSpec(ai, decl.Specs) {
						adding = decl
					}
				case token.TYPE:
					if hasUsedTypeSpec(ai, decl) {
						adding = decl
					}
				case token.VAR:
					if hasUsedValueSpec(ai, decl.Specs) {
						adding = decl
					}
				}
			case *ast.FuncDecl:
				id := decl.Name
				if !ai.IsUsed(id) {
					break
				}
				adding = decl
			}
			if adding != nil {
				ingr.decls = append(ingr.decls, adding)
				for ; cidx < len(f.Comments) && f.Comments[cidx].Pos() < adding.Pos(); cidx++ {
					// skip previous comments
				}
				var cgs []*ast.CommentGroup
				for ; cidx < len(f.Comments) && f.Comments[cidx].End() <= adding.End(); cidx++ {
					cgs = append(cgs, f.Comments[cidx])
				}
				ingr.comments[adding] = cgs
			}
		}
	})

	return ingr.newSquashedApp(ai), nil

}

// Fprint formats the source code and writes it to the given io.Writer
func (sa *SquashedApp) Fprint(w io.Writer) error {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "// Code generated by Gottani; see https://github.com/ktateish/gottani/. DO NOT EDIT.\n")
	fmt.Fprintf(buf, "package %s", sa.pkgName)
	pcfg := printer.Config{
		Mode:     printer.TabIndent | printer.UseSpaces,
		Tabwidth: 8,
		Indent:   0,
	}

	for _, decl := range sa.importDecls {
		fmt.Fprintf(buf, "\n\n")
		pcfg.Fprint(buf, sa.fset, decl)
	}

	lines := func(nd ast.Decl) (int, int) {
		var doc *ast.CommentGroup
		switch nd := nd.(type) {
		case *ast.GenDecl:
			doc = nd.Doc
		case *ast.FuncDecl:
			doc = nd.Doc
		}
		var start int
		if doc != nil {
			start = sa.fset.Position(doc.Pos()).Line
		} else {
			start = sa.fset.Position(nd.Pos()).Line
		}
		return start, sa.fset.Position(nd.End()).Line
	}
	base := func(nd ast.Node) int {
		return sa.fset.File(nd.Pos()).Base()
	}
	newlines := func(i int) int {
		if i == 0 || base(sa.decls[i-1]) != base(sa.decls[i]) {
			return math.MaxInt32
		}
		_, lastEnd := lines(sa.decls[i-1])
		thisStart, _ := lines(sa.decls[i])
		return max(1, thisStart - lastEnd)
	}
	min := func(a, b int) int {
		if a < b {
			return a
		}
		return b
	}

	for i, d := range sa.decls {
		nls := newlines(i)
		for j := 0; j < min(nls, 2); j++ {
			fmt.Fprintf(buf, "\n")
		}
		if nls <= 2 {
			pcfg.Mode &^= printer.SourcePos
		} else {
			pcfg.Mode |= printer.SourcePos
		}
		cnd := &printer.CommentedNode{
			Node:     d,
			Comments: sa.comments[d],
		}

		pcfg.Fprint(buf, sa.fset, cnd)
	}

	b, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting: %w", err)
	}
	w.Write(b)
	return nil
}

// ingredients for SquashedApp
type ingredients struct {
	importCDecls []*ast.GenDecl    // In `import "C"` notation, the C source is associated to GenDecl, not to ImportSpec, so the whole GenDecl is needed
	importCSpecs []*ast.ImportSpec // Not likely but `import ( ... /* <C Source> */\n<white spaces>"C" ...` format is allowed and this field is for that case
	importSpecs  []*ast.ImportSpec // For normal ImportSpecs. they can be packed into a single import ( ... ) notation

	decls []ast.Decl // for used GenDecls/FuncDecls

	comments map[ast.Decl][]*ast.CommentGroup // for comments in GenDecls/FuncDecls
}

func (ingr *ingredients) squashImports(ai appInfo, used map[string]bool) []ast.Decl {
	var res []ast.Decl

	// `import "C"` and `import ( ... )`
	for _, d := range ingr.importCDecls {
		res = append(res, d)
	}

	idecl := &ast.GenDecl{
		TokPos: token.NoPos,
		Tok:    token.IMPORT,
		Lparen: token.NoPos,
		Rparen: token.NoPos,
	}
	for _, s := range ingr.importCSpecs {
		idecl.Specs = append(idecl.Specs, s)
	}

	ispecs := squashImportSpecs(ai, used, ingr.importSpecs)

	for _, s := range ispecs {
		idecl.Specs = append(idecl.Specs, s)
	}
	if 0 < len(idecl.Specs) {
		res = append(res, idecl)
	}
	return res
}

func (ingr *ingredients) newUsedNames(ai appInfo) map[string]bool {
	// used identity in the target file
	used := make(map[string]bool)
	// collect names in scopes of each function body
	decls := make([]*ast.FuncDecl, 0, len(ingr.decls))
	for _, d := range ingr.decls {
		d, ok := d.(*ast.FuncDecl)
		if !ok {
			continue
		}
		decls = append(decls, d)
	}
	for _, d := range decls {
		ast.Inspect(d, func(node ast.Node) bool {
			id, ok := node.(*ast.Ident)
			if !ok {
				return true
			}
			if d.Name == id {
				// the function name has a object in Defs but it is package scope
				return false
			}
			obj := ai.TypesInfo().Defs[id]
			if obj == nil {
				return false
			}
			// obj != nil means this identity is function scope
			used[id.Name] = true
			return false
		})
	}
	return used
}

// newSquashedApp populates used items to a single *ast.Node deduping and renameing if needed.
// Note that the oriiginal ast.Nodes are modified so they are no longer used for rebuilding the original source
func (ingr *ingredients) newSquashedApp(ai appInfo) *SquashedApp {
	mainPkg := ai.Root()

	res := &SquashedApp{
		pkgName: mainPkg.Name,
		fset:    ai.FileSet(),
	}

	// memo for used identity in the target file
	used := ingr.newUsedNames(ai)

	res.importDecls = ingr.squashImports(ai, used)

	var mainDecls, otherDecls []ast.Decl
	for _, d := range ingr.decls {
		if ai.GetPackage(d) == mainPkg {
			mainDecls = append(mainDecls, d)
		} else {
			otherDecls = append(otherDecls, d)
		}
	}
	for _, decls := range [][]ast.Decl{mainDecls, otherDecls} {
		for _, d := range decls {
			switch d := d.(type) {
			case *ast.GenDecl:
				renameGenDecl(ai, used, d)
			case *ast.FuncDecl:
				renameFuncDecl(ai, used, d)
				if d.Body == nil {
					fixupExternFuncDecl(ai.GetPackage(d).Name, d)
				}
			}
		}
	}
	res.decls = removeInvalidSelector(ingr.decls)
	res.comments = ingr.comments

	return res
}

// fixupExternFuncDecl adds stub body for extern functions, typically
// implemented in assembly languages.
// The stub body jsut panics with a message that explains an extern function is
// not supported.
// It also removes compiler directives for extern functions.
//
// Example:
//
//     extern function like:
//
//     //go:noescape
//     func Add(a, b int) int
//
//     turns to:
//
//     func Add(a, b int) int { panic("gottani: extern asm is not supported: lib.Add") }
//
func fixupExternFuncDecl(pkgName string, fn *ast.FuncDecl) {
	// Remove compiler directives applicable only for FuncDecl without Body.
	// They cause errors when the FuncDecl has Body.
	fn.Doc.List = slices.DeleteFunc(fn.Doc.List, func(c *ast.Comment) bool {
		for _, dir := range []string{"noescape", "wasmimport", "linkname"} {
			if (strings.HasPrefix(c.Text, "//go:" + dir)) {
				return true
			}
		}
		return false
	})

	// Add sutb Body to panic when it is called.
	msg := &ast.BasicLit{
		Kind: token.STRING,
		Value: fmt.Sprintf(`"gottani: extern function is not supported: %s.%s"`, pkgName, fn.Name.Name),
	}
	panicCall := &ast.ExprStmt{
		X: &ast.CallExpr{
			Fun:  ast.NewIdent("panic"),
			Args: []ast.Expr{msg},
		},
	}
	stmts := []ast.Stmt{panicCall}
	fn.Body = &ast.BlockStmt{ List: stmts}
}

// *ast.SelectorExpr `lib.Foo()` in the original source is renamed to invalid `.Foo()`
// by squashImportSpecs() if the `lib` is a third party, non-standard, library.
// This function replaces the invalid SelectorExpr to valid *ast.Ident like `Foo()`
func removeInvalidSelector(decls []ast.Decl) []ast.Decl {
	var res []ast.Decl
	fn := func(c *astutil.Cursor) bool {
		if sel, ok := c.Node().(*ast.SelectorExpr); ok {
			if id, ok := sel.X.(*ast.Ident); ok && id.Name == "" {
				c.Replace(sel.Sel)
			}
			return true
		}
		return true
	}
	for _, d := range decls {
		res = append(res, astutil.Apply(d, fn, nil).(ast.Decl))
	}
	return res
}

// rename function name if needed.
func renameFuncDecl(ai appInfo, used map[string]bool, decl *ast.FuncDecl) {
	// Methods doesn't need renaming because they are type scope
	if decl.Recv != nil {
		return
	}
	// init() doesn't need renaming too because they can be duplicated
	if decl.Name.Name == "init" {
		return
	}
	if !used[decl.Name.Name] {
		used[decl.Name.Name] = true
		return
	}
	bp := ai.GetPackage(decl)
	prefix := bp.Name
	renameIdents(ai, used, prefix, []*ast.Ident{decl.Name})
}

// rename type, const, var name if needed.
// It scans all specs in the decl and rename all ident when one of them need
// renaming.  It is done for readability.
func renameGenDecl(ai appInfo, used map[string]bool, decl *ast.GenDecl) {
	var ids []*ast.Ident
	var needRename bool
	for _, spec := range decl.Specs {
		switch spec := spec.(type) {
		case *ast.TypeSpec:
			id := spec.Name
			ids = append(ids, id)
			needRename = needRename || used[id.Name]
		case *ast.ValueSpec:
			for _, id := range spec.Names {
				ids = append(ids, id)
				needRename = needRename || used[id.Name]
			}
		}
	}

	if needRename {
		bp := ai.GetPackage(decl)
		prefix := bp.Name
		renameIdents(ai, used, prefix, ids)
	} else {
		for _, id := range ids {
			used[id.Name] = true
		}
	}
}

// Rename a set of identities specified by the given ids adding the same name prefix
func renameIdents(ai appInfo, used map[string]bool, prefix string, ids []*ast.Ident) {
	// Find the safe prefix for the identifiers.
	// Initially the prefx candidate is package name, e.g. "foo".
	// When the candidate is not safe, add 'x' to the prefix, e.g. "xfoo"
	tns := make([]string, len(ids))

	for needRename := true; needRename; {
		needRename = false
		for i, id := range ids {
			tns[i] = fmt.Sprintf("%s_%s", prefix, id.Name)
			if used[tns[i]] {
				needRename = true
				prefix = "x" + prefix
				break
			}
		}
	}

	for i, id := range ids {
		id.Name = tns[i]
		renameRefererOfIdent(ai, id, tns[i])
		used[tns[i]] = true
	}
}

func hasUsedValueSpec(ai appInfo, specs []ast.Spec) bool {
	for _, spec := range specs {
		spec := spec.(*ast.ValueSpec)
		for _, id := range spec.Names {
			if ai.IsUsed(id) {
				return true
			}
		}
	}
	return false
}

func hasUsedTypeSpec(ai appInfo, decl *ast.GenDecl) bool {
	if ai.IsUsed(decl) {
		return true
	}
	for _, spec := range decl.Specs {
		spec := spec.(*ast.TypeSpec)
		if ai.IsUsed(spec) {
			return true
		}
	}
	return false
}

func collectUsedImportC(ai appInfo, ingr *ingredients, decl *ast.GenDecl) {
	for _, spec := range decl.Specs {
		spec, ok := spec.(*ast.ImportSpec)
		if !ok {
			continue
		}
		if spec.Path.Value != `"C"` {
			continue
		}
		if len(decl.Specs) == 1 {
			ingr.importCDecls = append(ingr.importCDecls, decl)
		} else {
			ingr.importCSpecs = append(ingr.importCSpecs, spec)
		}
	}
}

func collectUsedImport(ai appInfo, decl *ast.GenDecl) (specs []*ast.ImportSpec, cdecls []*ast.GenDecl, cspecs []*ast.ImportSpec) {
	for _, spec := range decl.Specs {
		spec, ok := spec.(*ast.ImportSpec)
		if !ok {
			continue
		}
		var isUsed bool
		ast.Inspect(spec, func(node ast.Node) bool {
			if isUsed {
				return false
			}
			if ai.IsUsed(node) {
				isUsed = true
				return false
			}
			return true
		})
		if !isUsed {
			continue
		}
		if spec.Path.Value == `"C"` {
			if len(decl.Specs) == 1 {
				cdecls = append(cdecls, decl)
			} else {
				cspecs = append(cspecs, spec)
			}
			continue
		}
		specs = append(specs, spec)
	}
	return
}

func createImportDeclFromCFile(fset *token.FileSet, name, path string) (*ast.GenDecl, error) {
	b, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("reading: %w", err)
	}
	format := `package main
/*
%s
*/
import "C"
`
	src := fmt.Sprintf(format, string(b))
	decl, err := parser.ParseFile(fset, name, src, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("parsing: %w", err)
	}
	return decl.Decls[0].(*ast.GenDecl), nil
}

func squashImportSpecs(ai appInfo, used map[string]bool, specs []*ast.ImportSpec) []*ast.ImportSpec {
	collected := make(map[string]bool)
	var res []*ast.ImportSpec
	for i, spec := range specs {
		path := strings.Trim(spec.Path.Value, `"`)
		f := ai.GetFile(spec)
		bp := ai.GetBuildPackage(path, f.Name.Name)
		if bp == nil {
			panic(fmt.Sprintf("unknown package: %s", path))
		}

		// non-standard packages will be embedded into the target source file
		if !bp.Goroot {
			// *ast.SelectorExpr using this empty name will be replaced by its .Sel. later
			renameRefererOfImportSpec(ai, spec, "")
			continue
		}

		if collected[path] {
			continue
		}
		collected[path] = true

		sames := []*ast.ImportSpec{spec}
		candidate := bp.Name

		// find same imports
		for j := i; j < len(specs); j++ {
			jpath := strings.Trim(specs[j].Path.Value, `"`)
			if path != jpath {
				continue
			}
			sames = append(sames, specs[j])
		}

		name := candidate
		for used[name] {
			name = "x" + name
		}
		used[name] = true

		for _, sp := range sames {
			renameRefererOfImportSpec(ai, sp, name)
		}

		if spec.Name == nil {
			obj := ai.TypesInfo().Implicits[spec]
			if obj.Name() != name {
				spec.Name = &ast.Ident{
					NamePos: token.NoPos,
					Name:    name,
				}
			}
		} else if spec.Name.Name != name {
			if bp.Name == name {
				spec.Name = nil
			} else {
				spec.Name.Name = name
			}
		}
		res = append(res, spec)
	}
	return res
}

// rename the name of identities referring the given spec.
func renameRefererOfImportSpec(ai appInfo, spec *ast.ImportSpec, to string) {
	if spec.Name != nil {
		renameRefererOfIdent(ai, spec.Name, to)
		return
	}
	for _, uid := range ai.GetReferrings(spec) {
		if uid.Name == to {
			continue
		}
		uid.Name = to
	}
}

// rename the name of identities referring the given id.
func renameRefererOfIdent(ai appInfo, id *ast.Ident, to string) {
	for _, uid := range ai.GetReferrings(id) {
		if uid.Name == to {
			continue
		}
		uid.Name = to
	}
}

// call f() for each *ast.File in all packages except standard ones.
func forEachFile(ai PackageInfo, fn func(bp *build.Package, f *ast.File)) {
	for _, bp := range ai.Packages() {
		for _, f := range ai.GetAstFiles(bp) {
			fn(bp, f)
		}
	}
}
